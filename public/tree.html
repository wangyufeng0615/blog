<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµªæ¼«åœ£è¯æ ‘ - WebAR ç²’å­äº’åŠ¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Segoe UI', sans-serif;
        }
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #video {
            display: none;
        }
        #pip-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 100;
        }
        #pip-canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-align: left;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            max-width: 300px;
            line-height: 1.6;
        }
        #debug {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
            z-index: 100;
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <video id="video" playsinline autoplay></video>
    <div id="container"></div>
    <div id="pip-container">
        <canvas id="pip-canvas"></canvas>
    </div>
    <div id="info">
        ğŸ„ æµªæ¼«åœ£è¯æ ‘<br><br>
        âœ‹ æ—‹è½¬æ‰‹è…• â†’ æ—‹è½¬æ ‘<br>
        ğŸ‘‹ å¿«é€ŸæŒ¥æ‰‹ â†’ å¹æ•£ç²’å­<br>
        ğŸ¤ å‰åç§»åŠ¨ â†’ ç¼©æ”¾å¤§å°
    </div>
    <div id="debug"></div>
    <div class="loading" id="loading">æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«</div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

    <script>

        // ============ é…ç½®å‚æ•° ============
        const CONFIG = {
            // åœ£è¯æ ‘
            treeParticleCount: 12000,
            treeHeight: 6,
            treeRadius: 2.8,
            trunkRadius: 0.35,
            trunkHeight: 0.6,
            // é›ªèŠ±
            snowCount: 1500,
            snowFallSpeed: 0.012,
            snowAreaSize: 16,
            snowHeight: 12,
            // åœ°é¢ç§¯é›ª
            groundSnowCount: 1000,
            // ç‰©ç†å‚æ•°
            damping: 0.94,
            returnForce: 0.012,
            windForce: 0.06,
            rotationSmoothing: 0.03,
            scaleSmoothing: 0.02,
            // æ‰‹åŠ¿å‚æ•°
            rotationThreshold: 0.03,
            windSpeedThreshold: 0.15,
            // è§†è§‰
            starCount: 200
        };

        // ============ å…¨å±€çŠ¶æ€ ============
        const state = {
            handDetected: false,
            handPosition: new THREE.Vector3(),
            handVelocity: new THREE.Vector3(),
            prevHandPosition: new THREE.Vector3(),
            // æ—‹è½¬ç›¸å…³ - å¤šçº§å¹³æ»‘
            handRotation: 0,
            smoothedHandRotation: 0,
            prevSmoothedRotation: 0,
            targetRotation: 0,
            currentRotation: 0,
            rotationVelocity: 0,
            // ç¼©æ”¾
            targetScale: 1,
            currentScale: 1,
            scaleVelocity: 0,
            // é£
            windDirection: new THREE.Vector3(),
            windStrength: 0,
            smoothedSpeed: 0,
            shakeIntensity: 0,
            // å¸§è®¡æ•°ï¼Œç”¨äºé™ä½æ›´æ–°é¢‘ç‡
            frameCount: 0
        };

        // ç”»ä¸­ç”»
        const pipCanvas = document.getElementById('pip-canvas');
        const pipCtx = pipCanvas.getContext('2d');
        pipCanvas.width = 320;
        pipCanvas.height = 240;

        // ============ Three.js åˆå§‹åŒ– ============
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a15, 0.025);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3.5, 11);
        camera.lookAt(0, 2.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x0a0a15, 1);
        document.getElementById('container').appendChild(renderer.domElement);

        // ============ åœ£è¯æ ‘ç²’å­ç³»ç»Ÿ ============
        class ChristmasTree {
            constructor(count) {
                this.count = count;
                this.geometry = new THREE.BufferGeometry();

                this.positions = new Float32Array(count * 3);
                this.originalPositions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);
                this.colors = new Float32Array(count * 3);
                this.sizes = new Float32Array(count);
                this.baseSizes = new Float32Array(count);
                this.phases = new Float32Array(count);
                this.isOrnament = new Uint8Array(count); // æ˜¯å¦æ˜¯è£…é¥°å“
                this.snowAccumulation = new Float32Array(count); // ç§¯é›ªé‡

                this.initParticles();
                this.createMesh();
            }

            initParticles() {
                // ç»å…¸åœ£è¯æ ‘ç»¿è‰²
                const darkGreen = new THREE.Color(0x0B3B0B);
                const midGreen = new THREE.Color(0x145214);
                const lightGreen = new THREE.Color(0x1E6B1E);

                // è£…é¥°çƒé¢œè‰²
                const ornamentColors = [
                    new THREE.Color(0xff0000), // çº¢
                    new THREE.Color(0xffd700), // é‡‘
                    new THREE.Color(0xc0c0c0), // é“¶
                    new THREE.Color(0x0066ff), // è“
                ];

                let idx = 0;

                // ===== ç»å…¸å±‚å å¼åœ£è¯æ ‘ =====
                // 3-4 å±‚é”¥å½¢ï¼Œæ¯å±‚åº•éƒ¨æœ‰çªå‡ºçš„"è£™è¾¹"

                const layers = [
                    { bottom: 0, top: 1.8, radiusBottom: 2.8, radiusTop: 2.0, particles: 0.28 },
                    { bottom: 1.2, top: 3.2, radiusBottom: 2.2, radiusTop: 1.4, particles: 0.26 },
                    { bottom: 2.6, top: 4.4, radiusBottom: 1.6, radiusTop: 0.8, particles: 0.22 },
                    { bottom: 3.8, top: 5.8, radiusBottom: 1.0, radiusTop: 0.15, particles: 0.14 },
                ];

                // ç»˜åˆ¶æ¯ä¸€å±‚
                for (const layer of layers) {
                    const layerCount = Math.floor(this.count * layer.particles);

                    for (let i = 0; i < layerCount && idx < this.count; i++) {
                        // é«˜åº¦åˆ†å¸ƒ - æ›´å¤šç²’å­åœ¨åº•éƒ¨è¾¹ç¼˜
                        let t = Math.random();
                        const y = layer.bottom + t * (layer.top - layer.bottom) + CONFIG.trunkHeight;

                        // åŠå¾„éšé«˜åº¦çº¿æ€§å‡å°
                        const heightRatio = t;
                        const maxRadius = layer.radiusBottom + (layer.radiusTop - layer.radiusBottom) * heightRatio;

                        // å¤§éƒ¨åˆ†ç²’å­åœ¨è¡¨é¢ï¼Œå½¢æˆå¯†å®çš„å¤–è§‚
                        let r;
                        const rand = Math.random();
                        if (rand < 0.7) {
                            // 70% åœ¨å¤–è¡¨é¢
                            r = maxRadius * (0.92 + Math.random() * 0.08);
                        } else if (rand < 0.9) {
                            // 20% åœ¨ä¸­å±‚
                            r = maxRadius * (0.6 + Math.random() * 0.3);
                        } else {
                            // 10% åœ¨å†…éƒ¨
                            r = maxRadius * Math.random() * 0.5;
                        }

                        const angle = Math.random() * Math.PI * 2;
                        const x = Math.cos(angle) * r;
                        const z = Math.sin(angle) * r;

                        const i3 = idx * 3;
                        this.positions[i3] = x;
                        this.positions[i3 + 1] = y;
                        this.positions[i3 + 2] = z;
                        this.originalPositions[i3] = x;
                        this.originalPositions[i3 + 1] = y;
                        this.originalPositions[i3 + 2] = z;

                        // ç»¿è‰² - æ ¹æ®æ·±åº¦å’Œé«˜åº¦å˜åŒ–
                        let color;
                        if (r > maxRadius * 0.85) {
                            color = lightGreen.clone();
                        } else if (r > maxRadius * 0.5) {
                            color = midGreen.clone();
                        } else {
                            color = darkGreen.clone();
                        }
                        // åŠ ä¸€ç‚¹éšæœºå˜åŒ–
                        color.r *= 0.9 + Math.random() * 0.2;
                        color.g *= 0.9 + Math.random() * 0.2;
                        color.b *= 0.9 + Math.random() * 0.2;

                        this.colors[i3] = color.r;
                        this.colors[i3 + 1] = color.g;
                        this.colors[i3 + 2] = color.b;

                        this.baseSizes[idx] = 0.07 + Math.random() * 0.04;
                        this.sizes[idx] = this.baseSizes[idx];
                        this.phases[idx] = Math.random() * Math.PI * 2;
                        this.isOrnament[idx] = 0;
                        this.snowAccumulation[idx] = 0;

                        idx++;
                    }
                }

                // ===== æ ‘å¹² =====
                const trunkCount = Math.floor(this.count * 0.03);
                for (let i = 0; i < trunkCount && idx < this.count; i++) {
                    const y = Math.random() * CONFIG.trunkHeight;
                    const angle = Math.random() * Math.PI * 2;
                    const r = CONFIG.trunkRadius * (0.7 + Math.random() * 0.3);

                    const i3 = idx * 3;
                    this.positions[i3] = Math.cos(angle) * r;
                    this.positions[i3 + 1] = y;
                    this.positions[i3 + 2] = Math.sin(angle) * r;
                    this.originalPositions[i3] = this.positions[i3];
                    this.originalPositions[i3 + 1] = this.positions[i3 + 1];
                    this.originalPositions[i3 + 2] = this.positions[i3 + 2];

                    const brown = new THREE.Color(0x4A3728);
                    this.colors[i3] = brown.r * (0.8 + Math.random() * 0.4);
                    this.colors[i3 + 1] = brown.g * (0.8 + Math.random() * 0.4);
                    this.colors[i3 + 2] = brown.b * (0.8 + Math.random() * 0.4);

                    this.baseSizes[idx] = 0.08;
                    this.sizes[idx] = 0.08;
                    this.phases[idx] = Math.random() * Math.PI * 2;
                    this.isOrnament[idx] = 0;
                    this.snowAccumulation[idx] = 0;
                    idx++;
                }

                // ===== æ ‘é¡¶æ˜Ÿæ˜Ÿ =====
                const starParticles = Math.floor(this.count * 0.015);
                const starY = CONFIG.treeHeight + CONFIG.trunkHeight + 0.2;

                for (let i = 0; i < starParticles && idx < this.count; i++) {
                    // äº”è§’æ˜Ÿåˆ†å¸ƒ
                    const t = i / starParticles;
                    const points = 5;
                    const angleStep = (Math.PI * 2) / points;
                    const baseAngle = t * Math.PI * 2 * 3; // å¤šåœˆ

                    const pointIndex = Math.floor((baseAngle % (Math.PI * 2)) / angleStep);
                    const inPoint = (baseAngle % angleStep) / angleStep;

                    // æ˜Ÿæ˜Ÿå½¢çŠ¶
                    const outerR = 0.35;
                    const innerR = 0.14;
                    const starR = inPoint < 0.5
                        ? outerR - (outerR - innerR) * (inPoint * 2)
                        : innerR + (outerR - innerR) * ((inPoint - 0.5) * 2);

                    const finalR = starR * (0.7 + Math.random() * 0.5);
                    const x = Math.cos(baseAngle) * finalR;
                    const z = Math.sin(baseAngle) * finalR;
                    const y = starY + (Math.random() - 0.5) * 0.15;

                    const i3 = idx * 3;
                    this.positions[i3] = x;
                    this.positions[i3 + 1] = y;
                    this.positions[i3 + 2] = z;
                    this.originalPositions[i3] = x;
                    this.originalPositions[i3 + 1] = y;
                    this.originalPositions[i3 + 2] = z;

                    // é‡‘è‰²
                    this.colors[i3] = 1.0;
                    this.colors[i3 + 1] = 0.85;
                    this.colors[i3 + 2] = 0.1;

                    this.baseSizes[idx] = 0.12 + Math.random() * 0.08;
                    this.sizes[idx] = this.baseSizes[idx];
                    this.phases[idx] = Math.random() * Math.PI * 2;
                    this.isOrnament[idx] = 1;
                    this.snowAccumulation[idx] = 0;
                    idx++;
                }

                // ===== è£…é¥°çƒ - å‡åŒ€åˆ†å¸ƒåœ¨æ ‘è¡¨é¢ =====
                const ornamentCount = Math.floor(this.count * 0.025);
                for (let i = 0; i < ornamentCount && idx < this.count; i++) {
                    // éšæœºé€‰ä¸€å±‚
                    const layerIdx = Math.floor(Math.random() * layers.length);
                    const layer = layers[layerIdx];

                    const t = Math.random();
                    const y = layer.bottom + t * (layer.top - layer.bottom) + CONFIG.trunkHeight;
                    const heightRatio = t;
                    const maxRadius = layer.radiusBottom + (layer.radiusTop - layer.radiusBottom) * heightRatio;

                    // è£…é¥°çƒåœ¨è¡¨é¢
                    const r = maxRadius * 1.02;
                    const angle = Math.random() * Math.PI * 2;

                    const i3 = idx * 3;
                    this.positions[i3] = Math.cos(angle) * r;
                    this.positions[i3 + 1] = y;
                    this.positions[i3 + 2] = Math.sin(angle) * r;
                    this.originalPositions[i3] = this.positions[i3];
                    this.originalPositions[i3 + 1] = this.positions[i3 + 1];
                    this.originalPositions[i3 + 2] = this.positions[i3 + 2];

                    const color = ornamentColors[Math.floor(Math.random() * ornamentColors.length)];
                    this.colors[i3] = color.r;
                    this.colors[i3 + 1] = color.g;
                    this.colors[i3 + 2] = color.b;

                    this.baseSizes[idx] = 0.15 + Math.random() * 0.1;
                    this.sizes[idx] = this.baseSizes[idx];
                    this.phases[idx] = Math.random() * Math.PI * 2;
                    this.isOrnament[idx] = 1;
                    this.snowAccumulation[idx] = 0;
                    idx++;
                }

                // ===== å½©ç¯ä¸² - èºæ—‹ç¼ ç»• =====
                const lightCount = Math.floor(this.count * 0.02);
                const spiralTurns = 6;

                for (let i = 0; i < lightCount && idx < this.count; i++) {
                    const t = i / lightCount;
                    // ä»åº•åˆ°é¡¶èºæ—‹ä¸Šå‡
                    const y = CONFIG.trunkHeight + t * CONFIG.treeHeight * 0.95;

                    // è®¡ç®—å½“å‰é«˜åº¦å¯¹åº”çš„åŠå¾„ï¼ˆè€ƒè™‘å±‚å ç»“æ„ï¼‰
                    let maxR = 0;
                    for (const layer of layers) {
                        const layerY = y - CONFIG.trunkHeight;
                        if (layerY >= layer.bottom && layerY <= layer.top) {
                            const lt = (layerY - layer.bottom) / (layer.top - layer.bottom);
                            const r = layer.radiusBottom + (layer.radiusTop - layer.radiusBottom) * lt;
                            maxR = Math.max(maxR, r);
                        }
                    }

                    if (maxR < 0.2) maxR = 0.2;

                    const spiralAngle = t * Math.PI * 2 * spiralTurns;
                    const r = maxR * 1.03;

                    const i3 = idx * 3;
                    this.positions[i3] = Math.cos(spiralAngle) * r;
                    this.positions[i3 + 1] = y;
                    this.positions[i3 + 2] = Math.sin(spiralAngle) * r;
                    this.originalPositions[i3] = this.positions[i3];
                    this.originalPositions[i3 + 1] = this.positions[i3 + 1];
                    this.originalPositions[i3 + 2] = this.positions[i3 + 2];

                    // å½©ç¯é¢œè‰²
                    const lightColors = [
                        [1.0, 0.1, 0.1],   // çº¢
                        [1.0, 0.8, 0.0],   // é»„
                        [0.1, 0.8, 0.1],   // ç»¿
                        [0.1, 0.4, 1.0],   // è“
                        [1.0, 0.4, 0.8],   // ç²‰
                    ];
                    const lc = lightColors[i % lightColors.length];
                    this.colors[i3] = lc[0];
                    this.colors[i3 + 1] = lc[1];
                    this.colors[i3 + 2] = lc[2];

                    this.baseSizes[idx] = 0.09;
                    this.sizes[idx] = 0.09;
                    this.phases[idx] = (i % 5) * Math.PI / 2.5;
                    this.isOrnament[idx] = 1;
                    this.snowAccumulation[idx] = 0;
                    idx++;
                }

                // å¡«å……å‰©ä½™ä¸ºæ ‘å¶
                while (idx < this.count) {
                    const layerIdx = Math.floor(Math.random() * layers.length);
                    const layer = layers[layerIdx];

                    const t = Math.random();
                    const y = layer.bottom + t * (layer.top - layer.bottom) + CONFIG.trunkHeight;
                    const heightRatio = t;
                    const maxRadius = layer.radiusBottom + (layer.radiusTop - layer.radiusBottom) * heightRatio;
                    const r = maxRadius * (0.5 + Math.random() * 0.5);
                    const angle = Math.random() * Math.PI * 2;

                    const i3 = idx * 3;
                    this.positions[i3] = Math.cos(angle) * r;
                    this.positions[i3 + 1] = y;
                    this.positions[i3 + 2] = Math.sin(angle) * r;
                    this.originalPositions[i3] = this.positions[i3];
                    this.originalPositions[i3 + 1] = this.positions[i3 + 1];
                    this.originalPositions[i3 + 2] = this.positions[i3 + 2];

                    const color = midGreen.clone();
                    color.multiplyScalar(0.8 + Math.random() * 0.4);
                    this.colors[i3] = color.r;
                    this.colors[i3 + 1] = color.g;
                    this.colors[i3 + 2] = color.b;

                    this.baseSizes[idx] = 0.05 + Math.random() * 0.03;
                    this.sizes[idx] = this.baseSizes[idx];
                    this.phases[idx] = Math.random() * Math.PI * 2;
                    this.isOrnament[idx] = 0;
                    this.snowAccumulation[idx] = 0;
                    idx++;
                }

                this.velocities.fill(0);

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
            }

            createMesh() {
                const vertexShader = `
                    attribute float size;
                    varying vec3 vColor;
                    varying float vDist;

                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vDist = -mvPosition.z;
                        gl_PointSize = size * (650.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;

                const fragmentShader = `
                    varying vec3 vColor;
                    varying float vDist;

                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;

                        float alpha = 1.0 - smoothstep(0.15, 0.5, r);
                        float fogFactor = 1.0 - smoothstep(8.0, 25.0, vDist);
                        alpha *= fogFactor;

                        // å‘å…‰
                        float glow = 1.0 + (0.5 - r) * 1.2;
                        vec3 finalColor = vColor * glow;

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;

                const material = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    transparent: true,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.mesh = new THREE.Points(this.geometry, material);
                scene.add(this.mesh);
            }

            update(time) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.color.array;
                const sizes = this.geometry.attributes.size.array;

                for (let i = 0; i < this.count; i++) {
                    const idx = i * 3;

                    // å›å½’åŠ›
                    const dx = this.originalPositions[idx] - positions[idx];
                    const dy = this.originalPositions[idx + 1] - positions[idx + 1];
                    const dz = this.originalPositions[idx + 2] - positions[idx + 2];

                    let ax = dx * CONFIG.returnForce;
                    let ay = dy * CONFIG.returnForce;
                    let az = dz * CONFIG.returnForce;

                    // é£åŠ›
                    if (state.windStrength > 0.01) {
                        const windEffect = state.windStrength * CONFIG.windForce;
                        ax += state.windDirection.x * windEffect * (0.5 + Math.random() * 0.5);
                        ay += state.windDirection.y * windEffect * 0.15;
                        az += state.windDirection.z * windEffect * (0.5 + Math.random() * 0.5);
                    }

                    // æŠ–åŠ¨æ•ˆæœï¼ˆç”¨äºæŠ–è½ç§¯é›ªï¼‰
                    if (state.shakeIntensity > 0.1) {
                        ax += (Math.random() - 0.5) * state.shakeIntensity * 0.02;
                        ay += (Math.random() - 0.5) * state.shakeIntensity * 0.02;
                        az += (Math.random() - 0.5) * state.shakeIntensity * 0.02;

                        // å‡å°‘ç§¯é›ª
                        this.snowAccumulation[i] *= 0.95;
                    }

                    this.velocities[idx] += ax;
                    this.velocities[idx + 1] += ay;
                    this.velocities[idx + 2] += az;

                    this.velocities[idx] *= CONFIG.damping;
                    this.velocities[idx + 1] *= CONFIG.damping;
                    this.velocities[idx + 2] *= CONFIG.damping;

                    positions[idx] += this.velocities[idx];
                    positions[idx + 1] += this.velocities[idx + 1];
                    positions[idx + 2] += this.velocities[idx + 2];

                    // è£…é¥°å“é—ªçƒ
                    if (this.isOrnament[i]) {
                        const twinkle = 0.7 + 0.3 * Math.sin(time * 4 + this.phases[i]);
                        sizes[i] = this.baseSizes[i] * twinkle;
                    } else {
                        // ç§¯é›ªæ•ˆæœ - è®©ç»¿è‰²å˜ç™½ï¼ˆä¸åˆ›å»ºæ–°å¯¹è±¡ï¼‰
                        const snow = this.snowAccumulation[i];
                        if (snow > 0.01) {
                            const snowFactor = snow * 0.5;
                            const origR = this.colors[idx] || 0.2;
                            const origG = this.colors[idx + 1] || 0.5;
                            const origB = this.colors[idx + 2] || 0.2;
                            colors[idx] = origR + (1 - origR) * snowFactor;
                            colors[idx + 1] = origG + (1 - origG) * snowFactor;
                            colors[idx + 2] = origB + (1 - origB) * snowFactor;
                        }
                    }
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;

                this.mesh.rotation.y = state.currentRotation;
                this.mesh.scale.setScalar(state.currentScale);
            }

            // ç®€åŒ–çš„ç§¯é›ª - éšæœºç»™è¡¨é¢ç²’å­åŠ ç§¯é›ª
            addSnowNearHeight(y) {
                // éšæœºé€‰å‡ ä¸ªæ¥è¿‘è¯¥é«˜åº¦çš„ç²’å­
                const attempts = 3;
                for (let a = 0; a < attempts; a++) {
                    const i = Math.floor(Math.random() * this.count);
                    if (this.isOrnament[i]) continue;

                    const idx = i * 3;
                    const py = this.originalPositions[idx + 1];

                    // é«˜åº¦æ¥è¿‘çš„ç²’å­
                    if (Math.abs(py - y) < 1.5) {
                        this.snowAccumulation[i] = Math.min(1, this.snowAccumulation[i] + 0.15);
                        break;
                    }
                }
            }
        }

        // ============ é›ªèŠ±ç³»ç»Ÿ ============
        class SnowSystem {
            constructor(count) {
                this.count = count;
                this.geometry = new THREE.BufferGeometry();

                this.positions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);
                this.sizes = new Float32Array(count);
                this.opacities = new Float32Array(count);

                this.initSnow();
                this.createMesh();
            }

            initSnow() {
                for (let i = 0; i < this.count; i++) {
                    this.resetSnowflake(i, true);
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('opacity', new THREE.BufferAttribute(this.opacities, 1));
            }

            resetSnowflake(i, randomY = false) {
                const idx = i * 3;
                this.positions[idx] = (Math.random() - 0.5) * CONFIG.snowAreaSize;
                this.positions[idx + 1] = randomY
                    ? Math.random() * CONFIG.snowHeight
                    : CONFIG.snowHeight + Math.random() * 2;
                this.positions[idx + 2] = (Math.random() - 0.5) * CONFIG.snowAreaSize;

                this.velocities[idx] = (Math.random() - 0.5) * 0.01;
                this.velocities[idx + 1] = -CONFIG.snowFallSpeed * (0.5 + Math.random() * 0.5);
                this.velocities[idx + 2] = (Math.random() - 0.5) * 0.01;

                this.sizes[i] = 0.03 + Math.random() * 0.05;
                this.opacities[i] = 0.6 + Math.random() * 0.4;
            }

            createMesh() {
                const vertexShader = `
                    attribute float size;
                    attribute float opacity;
                    varying float vOpacity;

                    void main() {
                        vOpacity = opacity;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (400.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;

                const fragmentShader = `
                    varying float vOpacity;

                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;

                        float alpha = (1.0 - r * 2.0) * vOpacity;
                        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
                    }
                `;

                const material = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.mesh = new THREE.Points(this.geometry, material);
                scene.add(this.mesh);
            }

            update(tree, groundSnow) {
                const positions = this.geometry.attributes.position.array;
                const windX = state.windDirection.x * state.windStrength * 0.005;
                const windZ = state.windDirection.z * state.windStrength * 0.005;
                const hasWind = state.windStrength > 0.05;

                for (let i = 0; i < this.count; i++) {
                    const idx = i * 3;

                    // é£çš„å½±å“
                    if (hasWind) {
                        this.velocities[idx] += windX;
                        this.velocities[idx + 2] += windZ;
                    }

                    // è½»å¾®éšæœºé£˜åŠ¨
                    this.velocities[idx] += (Math.random() - 0.5) * 0.001;
                    this.velocities[idx + 2] += (Math.random() - 0.5) * 0.001;

                    // é€Ÿåº¦é™åˆ¶
                    this.velocities[idx] *= 0.98;
                    this.velocities[idx + 2] *= 0.98;

                    // æ›´æ–°ä½ç½®
                    positions[idx] += this.velocities[idx];
                    positions[idx + 1] += this.velocities[idx + 1];
                    positions[idx + 2] += this.velocities[idx + 2];

                    const x = positions[idx];
                    const y = positions[idx + 1];
                    const z = positions[idx + 2];

                    // ç®€åŒ–çš„æ ‘ç¢°æ’æ£€æµ‹
                    const treeY = y - CONFIG.trunkHeight;
                    if (treeY > 0 && treeY < CONFIG.treeHeight) {
                        const maxR = CONFIG.treeRadius * (1 - treeY / CONFIG.treeHeight * 0.85);
                        const distXZ = x * x + z * z;

                        if (distXZ < maxR * maxR && Math.random() < 0.015) {
                            tree.addSnowNearHeight(y);
                            this.resetSnowflake(i);
                            continue;
                        }
                    }

                    // è½åˆ°åœ°é¢
                    if (y < 0) {
                        groundSnow.addSnowAt(x, z);
                        this.resetSnowflake(i);
                        continue;
                    }

                    // è¶…å‡ºèŒƒå›´é‡ç½®
                    const halfSize = CONFIG.snowAreaSize * 0.5;
                    if (x < -halfSize || x > halfSize || z < -halfSize || z > halfSize) {
                        this.resetSnowflake(i);
                    }
                }

                this.geometry.attributes.position.needsUpdate = true;
            }
        }

        // ============ åœ°é¢ç§¯é›ªç³»ç»Ÿ ============
        class GroundSnow {
            constructor(count) {
                this.count = count;
                this.geometry = new THREE.BufferGeometry();

                this.positions = new Float32Array(count * 3);
                this.sizes = new Float32Array(count);
                this.opacities = new Float32Array(count);
                this.activeCount = 0;

                this.initGround();
                this.createMesh();
            }

            initGround() {
                // é¢„è®¾ä¸€äº›åŸºç¡€ç§¯é›ª
                for (let i = 0; i < this.count; i++) {
                    const idx = i * 3;
                    const angle = Math.random() * Math.PI * 2;
                    const r = 1 + Math.random() * 8;
                    this.positions[idx] = Math.cos(angle) * r;
                    this.positions[idx + 1] = -0.05 + Math.random() * 0.1;
                    this.positions[idx + 2] = Math.sin(angle) * r;
                    this.sizes[i] = 0.05 + Math.random() * 0.08;
                    this.opacities[i] = i < this.count * 0.3 ? (0.3 + Math.random() * 0.3) : 0;
                }
                this.activeCount = Math.floor(this.count * 0.3);
                this.needsUpdate = false;

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('opacity', new THREE.BufferAttribute(this.opacities, 1));
            }

            createMesh() {
                const vertexShader = `
                    attribute float size;
                    attribute float opacity;
                    varying float vOpacity;

                    void main() {
                        vOpacity = opacity;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (500.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;

                const fragmentShader = `
                    varying float vOpacity;

                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;

                        float alpha = (1.0 - r * 1.5) * vOpacity;
                        gl_FragColor = vec4(0.95, 0.97, 1.0, alpha);
                    }
                `;

                const material = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.mesh = new THREE.Points(this.geometry, material);
                scene.add(this.mesh);
            }

            addSnowAt(x, z) {
                if (this.activeCount >= this.count) {
                    // å¾ªç¯è¦†ç›–æ—§çš„
                    this.activeCount = 0;
                }

                const idx = this.activeCount * 3;
                this.positions[idx] = x + (Math.random() - 0.5) * 0.3;
                this.positions[idx + 1] = Math.random() * 0.08;
                this.positions[idx + 2] = z + (Math.random() - 0.5) * 0.3;
                this.sizes[this.activeCount] = 0.05 + Math.random() * 0.05;
                this.opacities[this.activeCount] = 0.4 + Math.random() * 0.3;

                this.activeCount++;
                this.needsUpdate = true;
            }

            update() {
                // æ‰¹é‡æ›´æ–°
                if (this.needsUpdate) {
                    this.geometry.attributes.position.needsUpdate = true;
                    this.geometry.attributes.opacity.needsUpdate = true;
                    this.geometry.attributes.size.needsUpdate = true;
                    this.needsUpdate = false;
                }

                // é£å¹ç§¯é›ªï¼ˆé™ä½é¢‘ç‡ï¼‰
                if (state.windStrength > 0.4 && Math.random() < 0.3) {
                    const positions = this.geometry.attributes.position.array;
                    const opacities = this.geometry.attributes.opacity.array;
                    const windX = state.windDirection.x * 0.08;
                    const windZ = state.windDirection.z * 0.08;

                    // åªå¤„ç†éƒ¨åˆ†ç²’å­
                    const step = Math.max(1, Math.floor(this.activeCount / 50));
                    for (let i = 0; i < this.activeCount; i += step) {
                        const idx = i * 3;
                        positions[idx] += windX;
                        positions[idx + 2] += windZ;
                        opacities[i] *= 0.97;
                    }
                    this.geometry.attributes.position.needsUpdate = true;
                    this.geometry.attributes.opacity.needsUpdate = true;
                }
            }
        }

        // ============ èƒŒæ™¯æ˜Ÿæ˜Ÿ ============
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.starCount * 3);
            const colors = new Float32Array(CONFIG.starCount * 3);

            for (let i = 0; i < CONFIG.starCount; i++) {
                const idx = i * 3;
                const radius = 40 + Math.random() * 60;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.6; // ä¸ŠåŠçƒ

                positions[idx] = radius * Math.sin(phi) * Math.cos(theta);
                positions[idx + 1] = radius * Math.cos(phi) + 10;
                positions[idx + 2] = radius * Math.sin(phi) * Math.sin(theta);

                const temp = Math.random();
                if (temp < 0.3) {
                    colors[idx] = 0.8; colors[idx + 1] = 0.85; colors[idx + 2] = 1.0;
                } else if (temp < 0.6) {
                    colors[idx] = 1.0; colors[idx + 1] = 0.95; colors[idx + 2] = 0.8;
                } else {
                    colors[idx] = 1.0; colors[idx + 1] = 1.0; colors[idx + 2] = 1.0;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.12,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
            return stars;
        }

        // ============ åº•éƒ¨å…‰æ™• ============
        function createGroundGlow() {
            const geometry = new THREE.PlaneGeometry(18, 18);
            const material = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vec2 center = vUv - 0.5;
                        float dist = length(center);
                        float alpha = smoothstep(0.5, 0.1, dist) * 0.35;

                        vec3 red = vec3(0.6, 0.15, 0.1);
                        vec3 green = vec3(0.1, 0.5, 0.2);
                        vec3 gold = vec3(0.7, 0.5, 0.1);

                        float t = sin(time * 0.3) * 0.5 + 0.5;
                        vec3 color = mix(mix(red, green, t), gold, sin(time * 0.5 + 1.0) * 0.3 + 0.3);

                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.05;
            scene.add(plane);
            return plane;
        }

        // ============ ç»˜åˆ¶æ‰‹éƒ¨æ ‡è®° ============
        function drawHandLandmarks(landmarks, ctx, width, height) {
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],
                [0, 5], [5, 6], [6, 7], [7, 8],
                [0, 9], [9, 10], [10, 11], [11, 12],
                [0, 13], [13, 14], [14, 15], [15, 16],
                [0, 17], [17, 18], [18, 19], [19, 20],
                [5, 9], [9, 13], [13, 17]
            ];

            ctx.strokeStyle = 'rgba(0, 255, 128, 0.8)';
            ctx.lineWidth = 2;
            connections.forEach(([i, j]) => {
                ctx.beginPath();
                ctx.moveTo(landmarks[i].x * width, landmarks[i].y * height);
                ctx.lineTo(landmarks[j].x * width, landmarks[j].y * height);
                ctx.stroke();
            });

            landmarks.forEach((point, i) => {
                const x = point.x * width;
                const y = point.y * height;
                const isTip = [4, 8, 12, 16, 20].includes(i);

                ctx.fillStyle = isTip ? 'rgba(255, 100, 100, 1)' : 'rgba(0, 200, 255, 1)';
                ctx.beginPath();
                ctx.arc(x, y, isTip ? 5 : 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ============ MediaPipe åˆå§‹åŒ– ============
        async function initHandTracking() {
            const video = document.getElementById('video');
            const loading = document.getElementById('loading');

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                loading.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´';
                return;
            }

            try {
                loading.textContent = 'è¯·æ±‚æ‘„åƒå¤´æƒé™...';

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }
                });

                video.srcObject = stream;
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => video.play().then(resolve).catch(reject);
                    video.onerror = reject;
                    setTimeout(() => reject(new Error('è¶…æ—¶')), 10000);
                });

                loading.textContent = 'åŠ è½½æ‰‹åŠ¿æ¨¡å‹...';

                const hands = new window.Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    pipCtx.clearRect(0, 0, pipCanvas.width, pipCanvas.height);
                    pipCtx.drawImage(video, 0, 0, pipCanvas.width, pipCanvas.height);

                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        drawHandLandmarks(results.multiHandLandmarks[0], pipCtx, pipCanvas.width, pipCanvas.height);
                    }
                    onHandResults(results);
                });

                await hands.initialize();
                loading.textContent = 'å¯åŠ¨ä¸­...';

                async function processFrame() {
                    if (video.readyState >= 2) {
                        await hands.send({ image: video });
                    }
                    requestAnimationFrame(processFrame);
                }
                processFrame();

                loading.style.display = 'none';

            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                loading.textContent = error.name === 'NotAllowedError'
                    ? 'æ‘„åƒå¤´æƒé™è¢«æ‹’ç»'
                    : 'åˆå§‹åŒ–å¤±è´¥: ' + error.message;
            }
        }

        // ============ æ‰‹åŠ¿å¤„ç† ============
        function onHandResults(results) {
            const debug = document.getElementById('debug');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                state.handDetected = true;

                const wrist = landmarks[0];
                const middleBase = landmarks[9];
                const palm = {
                    x: (wrist.x + middleBase.x) / 2,
                    y: (wrist.y + middleBase.y) / 2,
                    z: (wrist.z + middleBase.z) / 2
                };

                const newPos = new THREE.Vector3(
                    (0.5 - palm.x) * 10,
                    (0.5 - palm.y) * 8 + 2,
                    palm.z * 5
                );

                state.prevHandPosition.copy(state.handPosition);
                state.handPosition.copy(newPos);

                state.handVelocity.subVectors(state.handPosition, state.prevHandPosition);
                const instantSpeed = state.handVelocity.length();
                state.smoothedSpeed = state.smoothedSpeed * 0.7 + instantSpeed * 0.3;

                // æŠ–åŠ¨å¼ºåº¦
                state.shakeIntensity = state.smoothedSpeed * 5;

                // æ‰‹æŒå¤§å°
                const thumbTip = landmarks[4];
                const pinkyTip = landmarks[20];
                const palmWidth = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) +
                    Math.pow(thumbTip.y - pinkyTip.y, 2)
                );

                const targetScale = 0.6 + palmWidth * 3;
                state.targetScale = Math.max(0.6, Math.min(1.8, targetScale));

                // æ‰‹è…•æ—‹è½¬ - ç”¨é£ŸæŒ‡æ ¹åˆ°å°æŒ‡æ ¹çš„è¿çº¿è§’åº¦ï¼ˆæ‰‹æŒå€¾æ–œçš„ç›´æ¥æŒ‡æ ‡ï¼‰
                const indexMcp = landmarks[5];  // é£ŸæŒ‡æ ¹éƒ¨
                const pinkyMcp = landmarks[17]; // å°æŒ‡æ ¹éƒ¨

                // è®¡ç®—æ‰‹æŒå€¾æ–œè§’åº¦
                const rawRotation = Math.atan2(
                    pinkyMcp.y - indexMcp.y,
                    pinkyMcp.x - indexMcp.x
                );

                // å¹³æ»‘å¤„ç†è§’åº¦ï¼ˆå¤„ç† -PI åˆ° PI çš„è·¨è¶Šï¼‰
                let angleDiff = rawRotation - state.smoothedHandRotation;
                if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                // å¹³æ»‘å› å­ï¼š0.25 æ¯”è¾ƒçµæ•åˆä¸ä¼šå¤ªæŠ–
                state.smoothedHandRotation += angleDiff * 0.25;

                // è®¡ç®—è§’åº¦å˜åŒ–é‡
                let rotationDelta = state.smoothedHandRotation - state.prevSmoothedRotation;
                state.prevSmoothedRotation = state.smoothedHandRotation;

                // å¤„ç†è§’åº¦è·¨è¶Š
                if (rotationDelta > Math.PI) rotationDelta -= Math.PI * 2;
                if (rotationDelta < -Math.PI) rotationDelta += Math.PI * 2;

                // æ­»åŒº + è·³å˜è¿‡æ»¤
                if (Math.abs(rotationDelta) > 0.005 && Math.abs(rotationDelta) < 0.3) {
                    state.targetRotation -= rotationDelta * 2.5;
                }

                // æŒ¥æ‰‹é£æš´
                if (state.smoothedSpeed > CONFIG.windSpeedThreshold) {
                    state.windStrength = Math.min(1, (state.smoothedSpeed - CONFIG.windSpeedThreshold) * 3);
                    state.windDirection.copy(state.handVelocity).normalize();
                } else {
                    state.windStrength *= 0.92;
                }

                debug.innerHTML = `
                    æ‰‹åŠ¿: âœ“<br>
                    é£åŠ›: ${state.windStrength.toFixed(2)}<br>
                    ç¼©æ”¾: ${state.currentScale.toFixed(2)}
                `;
            } else {
                state.handDetected = false;
                state.windStrength *= 0.95;
                state.shakeIntensity *= 0.9;
                debug.innerHTML = 'æ‰‹åŠ¿: æœªæ£€æµ‹';
            }
        }

        // ============ å¹³æ»‘çŠ¶æ€æ›´æ–° ============
        function updateSmoothState() {
            // æ—‹è½¬ - å¼¹ç°§é˜»å°¼ç³»ç»Ÿ
            const rotationDiff = state.targetRotation - state.currentRotation;
            // å¼¹ç°§åŠ›ï¼ˆå¢å¤§ä»¥æé«˜å“åº”é€Ÿåº¦ï¼‰
            state.rotationVelocity += rotationDiff * 0.08;
            // é˜»å°¼
            state.rotationVelocity *= 0.85;
            // é€Ÿåº¦é™åˆ¶
            state.rotationVelocity = Math.max(-0.15, Math.min(0.15, state.rotationVelocity));
            state.currentRotation += state.rotationVelocity;

            // ç¼©æ”¾
            const scaleDiff = state.targetScale - state.currentScale;
            state.scaleVelocity += scaleDiff * 0.04;
            state.scaleVelocity *= 0.85;
            state.currentScale += state.scaleVelocity;
        }

        // ============ åˆ›å»ºåœºæ™¯ ============
        const tree = new ChristmasTree(CONFIG.treeParticleCount);
        const snow = new SnowSystem(CONFIG.snowCount);
        const groundSnow = new GroundSnow(CONFIG.groundSnowCount);
        const stars = createStars();
        const groundGlow = createGroundGlow();

        // ============ ä¸»å¾ªç¯ ============
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);

            const time = currentTime * 0.001;
            lastTime = currentTime;

            updateSmoothState();
            tree.update(time);
            snow.update(tree, groundSnow);
            groundSnow.update();

            stars.rotation.y += 0.00003;
            groundGlow.material.uniforms.time.value = time;

            renderer.render(scene, camera);
        }

        // ============ å“åº”å¼ ============
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============ å¯åŠ¨ ============
        initHandTracking();
        animate(0);

    </script>
</body>
</html>
